import itertools

def change_format(string, type):
    if type == "hex2bin":
        mapping = { '0': '0000', '1': '0001', '2': '0010', '3': '0011', '4': '0100',
                    '5': '0101', '6': '0110', '7': '0111', '8': '1000', '9': '1001',
                    'a': '1010', 'b': '1011', 'c': '1100', 'd': '1101', 'e': '1110',
                    'f': '1111' }
        size = 1
    elif type == "bin2hex":
        mapping = { '0000': '0', '0001': '1', '0010': '2', '0011': '3',
                    '0100': '4', '0101': '5', '0110': '6', '0111': '7',
                    '1000': '8', '1001': '9', '1010': 'a', '1011': 'b',
                    '1100': 'c', '1101': 'd', '1110': 'e', '1111': 'f' }
        size = 4
    elif type == "bin2base64":
        mapping = { '000000': 'A', '000001': 'B', '000010': 'C', '000011': 'D', '000100': 'E', '000101': 'F', '000110': 'G', '000111': 'H',
                    '001000': 'I', '001001': 'J', '001010': 'K', '001011': 'L', '001100': 'M', '001101': 'N', '001110': 'O', '001111': 'P',
                    '010000': 'Q', '010001': 'R', '010010': 'S', '010011': 'T', '010100': 'U', '010101': 'V', '010110': 'W', '010111': 'X',
                    '011000': 'Y', '011001': 'Z', '011010': 'a', '011011': 'b', '011100': 'c', '011101': 'd', '011110': 'e', '011111': 'f',
                    '100000': 'g', '100001': 'h', '100010': 'i', '100011': 'j', '100100': 'k', '100101': 'l', '100110': 'm', '100111': 'n',
                    '101000': 'o', '101001': 'p', '101010': 'q', '101011': 'r', '101100': 's', '101101': 't', '101110': 'u', '101111': 'v',
                    '110000': 'w', '110001': 'x', '110010': 'y', '110011': 'z', '110100': '0', '110101': '1', '110110': '2', '110111': '3',
                    '111000': '4', '111001': '5', '111010': '6', '111011': '7', '111100': '8', '111101': '9', '111110': '+', '111111': '/' }
        size = 6
    
    return "".join(mapping.get(string[i:i+size]) for i in range(0, len(string), size))

def binary_xor(a, b):
    return "".join(str(int(x) ^ int(y)) for (x, y) in zip(a, b))

def binary_xor_cyclic(a, b):
    return "".join(str(int(x) ^ int(y)) for (x, y) in zip(a, itertools.cycle(b)))

def repeating_key_xor(plaintext, key):
    plaintext_bin = ''.join(format(ord(i), '08b') for i in plaintext)
    key_bin = ''.join(format(ord(i), '08b') for i in key)
    return binary_xor_cyclic(plaintext_bin, key_bin)
